<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n8n 시스템 모니터링 및 알림 자동화 - 엔터프라이즈 가이드</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
        }
        
        .container {
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #2C5364 0%, #203A43 50%, #0F2027 100%);
            padding: 30px 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 4px 0 15px rgba(0,0,0,0.1);
        }
        
        .sidebar h2 {
            color: white;
            font-size: 1.4em;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .sidebar ul {
            list-style: none;
        }
        
        .sidebar li {
            margin-bottom: 15px;
        }
        
        .sidebar a {
            color: rgba(255,255,255,0.9);
            text-decoration: none;
            display: block;
            padding: 12px 15px;
            border-radius: 8px;
            transition: all 0.3s;
            background: rgba(255,255,255,0.05);
        }
        
        .sidebar a:hover {
            background: rgba(255,255,255,0.15);
            transform: translateX(5px);
        }
        
        .sidebar .active {
            background: rgba(255,255,255,0.2);
            font-weight: bold;
        }
        
        .main-content {
            margin-left: 280px;
            width: calc(100% - 280px);
            padding: 40px;
            background: white;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 60px 40px;
            border-radius: 15px;
            margin-bottom: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 20px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }
        
        .section {
            background: white;
            padding: 40px;
            margin-bottom: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            border-left: 5px solid #e74c3c;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e6ed;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .code-block {
            background: #1e2936;
            color: #e0e6ed;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .workflow-step {
            background: #fff5f5;
            padding: 25px;
            margin: 20px 0;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
        }
        
        .workflow-step h4 {
            color: #c0392b;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .feature-card {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #fdcb6e;
            transition: all 0.3s;
            color: #2d3436;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .feature-card h4 {
            color: #2d3436;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .alert {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .alert-danger {
            background: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .alert-success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .monitoring-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .metric-card h3 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .metric-card p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }
        
        th {
            background: #e74c3c;
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .dashboard-preview {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 10px;
            margin: 30px 0;
            border: 2px dashed #dee2e6;
        }
        
        .dashboard-preview h4 {
            color: #495057;
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>📊 시스템 모니터링</h2>
            <ul>
                <li><a href="#overview" class="active">개요</a></li>
                <li><a href="#architecture">모니터링 아키텍처</a></li>
                <li><a href="#metrics">핵심 메트릭</a></li>
                <li><a href="#alerting">알림 시스템</a></li>
                <li><a href="#dashboards">대시보드 구성</a></li>
                <li><a href="#integration">도구 통합</a></li>
                <li><a href="#automation">자동화 워크플로우</a></li>
                <li><a href="#escalation">에스컬레이션</a></li>
                <li><a href="#maintenance">예방적 유지관리</a></li>
                <li><a href="#case-studies">실제 구현 사례</a></li>
            </ul>
        </aside>
        
        <main class="main-content">
            <div class="header">
                <h1>📊 시스템 모니터링 및 알림 자동화</h1>
                <p>n8n을 활용한 엔터프라이즈급 인프라 모니터링 및 지능형 알림 시스템 구축</p>
            </div>
            
            <section id="overview" class="section">
                <h2>🎯 모니터링 자동화의 비즈니스 가치</h2>
                <p>
                    현대 IT 인프라는 복잡하고 분산되어 있어 수동 모니터링으로는 한계가 있습니다. n8n을 활용한 
                    자동화된 모니터링 시스템은 장애를 사전에 예방하고, 발생 시 신속한 대응을 가능하게 합니다.
                    이를 통해 서비스 가용성을 극대화하고 비즈니스 연속성을 보장할 수 있습니다.
                </p>
                
                <div class="monitoring-metrics">
                    <div class="metric-card">
                        <h3>99.9%</h3>
                        <p>시스템 가용성 향상</p>
                    </div>
                    <div class="metric-card">
                        <h3>75%</h3>
                        <p>장애 감지 시간 단축</p>
                    </div>
                    <div class="metric-card">
                        <h3>60%</h3>
                        <p>운영 비용 절감</p>
                    </div>
                    <div class="metric-card">
                        <h3>24/7</h3>
                        <p>무중단 모니터링</p>
                    </div>
                </div>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>🔄 실시간 모니터링</h4>
                        <p>서버, 애플리케이션, 네트워크, 데이터베이스의 모든 메트릭을 실시간으로 수집하고 분석합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>🚨 지능형 알림</h4>
                        <p>임계값 기반 알림과 머신러닝을 활용한 이상 징후 탐지로 false positive를 최소화합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>🎯 맞춤형 대시보드</h4>
                        <p>역할별, 서비스별 맞춤형 대시보드를 통해 필요한 정보에 빠르게 접근할 수 있습니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>⚡ 자동 복구</h4>
                        <p>일반적인 문제에 대한 자동 복구 프로세스를 통해 인적 개입 없이 문제를 해결합니다.</p>
                    </div>
                </div>
            </section>
            
            <section id="architecture" class="section">
                <h2>🏗️ 모니터링 아키텍처 설계</h2>
                
                <h3>계층형 모니터링 구조</h3>
                <p>
                    엔터프라이즈 환경에서는 다층 모니터링 아키텍처를 통해 인프라부터 비즈니스 메트릭까지 
                    전방위적으로 관찰할 수 있어야 합니다.
                </p>
                
                <div class="workflow-step">
                    <h4>Infrastructure Layer (인프라 계층)</h4>
                    <div class="code-block">
# Prometheus 설정 예제
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"
  - "recording_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
      
  - job_name: 'node-exporter'
    static_configs:
      - targets: 
        - 'server1:9100'
        - 'server2:9100'
        - 'server3:9100'
        
  - job_name: 'blackbox'
    metrics_path: /probe
    params:
      module: [http_2xx]
    static_configs:
      - targets:
        - https://api.company.com
        - https://web.company.com
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: blackbox-exporter:9115
                    </div>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>모니터링 계층</th>
                            <th>수집 대상</th>
                            <th>도구</th>
                            <th>알림 임계값</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>인프라</td>
                            <td>CPU, 메모리, 디스크, 네트워크</td>
                            <td>Prometheus, Node Exporter</td>
                            <td>CPU 80%, 메모리 85%</td>
                        </tr>
                        <tr>
                            <td>플랫폼</td>
                            <td>Kubernetes, Docker, 로드밸런서</td>
                            <td>cAdvisor, kube-state-metrics</td>
                            <td>Pod 재시작, 노드 다운</td>
                        </tr>
                        <tr>
                            <td>애플리케이션</td>
                            <td>응답시간, 처리량, 에러율</td>
                            <td>APM, 커스텀 메트릭</td>
                            <td>응답시간 2초, 에러율 5%</td>
                        </tr>
                        <tr>
                            <td>비즈니스</td>
                            <td>매출, 사용자 활동, 전환율</td>
                            <td>Analytics API, 커스텀 대시보드</td>
                            <td>매출 10% 하락</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <section id="metrics" class="section">
                <h2>📈 핵심 메트릭 정의</h2>
                
                <h3>RED 메트릭 (Rate, Errors, Duration)</h3>
                <div class="workflow-step">
                    <h4>서비스별 핵심 성능 지표</h4>
                    <div class="code-block">
// n8n 워크플로우: 애플리케이션 메트릭 수집
{
  "nodes": [
    {
      "name": "Collect App Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "GET",
        "url": "https://{{$json.service}}.company.com/metrics",
        "responseFormat": "json"
      }
    },
    {
      "name": "Parse RED Metrics",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
const metrics = items[0].json;
const serviceName = $input.item.json.service;

// Rate (요청 처리율)
const rate = metrics.http_requests_per_second || 0;

// Errors (에러율)
const totalRequests = metrics.http_requests_total || 1;
const errorRequests = metrics.http_requests_errors_total || 0;
const errorRate = (errorRequests / totalRequests) * 100;

// Duration (응답 시간)
const avgDuration = metrics.http_request_duration_seconds_avg || 0;
const p95Duration = metrics.http_request_duration_seconds_p95 || 0;

return [{
  json: {
    service: serviceName,
    timestamp: new Date().toISOString(),
    rate: rate,
    errorRate: errorRate,
    avgDuration: avgDuration,
    p95Duration: p95Duration,
    health: {
      rate: rate > 10 ? 'healthy' : 'warning',
      errors: errorRate < 5 ? 'healthy' : errorRate < 10 ? 'warning' : 'critical',
      duration: p95Duration < 2 ? 'healthy' : p95Duration < 5 ? 'warning' : 'critical'
    }
  }
}];
`
      }
    }
  ]
}
                    </div>
                </div>
                
                <h3>USE 메트릭 (Utilization, Saturation, Errors)</h3>
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>📊 Utilization (사용률)</h4>
                        <p>CPU, 메모리, 디스크, 네트워크 사용률을 지속적으로 모니터링하여 리소스 부족 상황을 예측합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>⚡ Saturation (포화도)</h4>
                        <p>큐 길이, 대기 시간, 스레드풀 사용량 등을 통해 시스템의 포화 상태를 감지합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>❌ Errors (에러)</h4>
                        <p>하드웨어 오류, 소프트웨어 예외, 네트워크 장애 등 모든 종류의 에러를 추적합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>🔍 Custom Metrics</h4>
                        <p>비즈니스 특성에 맞는 커스텀 메트릭을 정의하여 도메인 특화 모니터링을 구현합니다.</p>
                    </div>
                </div>
            </section>
            
            <section id="alerting" class="section">
                <h2>🚨 지능형 알림 시스템</h2>
                
                <h3>다차원 알림 전략</h3>
                <p>
                    효과적인 알림 시스템은 중요도에 따른 알림 분류, 알림 피로도 방지, 
                    그리고 상황별 적절한 대응 방안을 제공해야 합니다.
                </p>
                
                <div class="workflow-step">
                    <h4>알림 규칙 엔진</h4>
                    <div class="code-block">
// n8n 알림 라우팅 워크플로우
{
  "name": "Smart Alert Router",
  "nodes": [
    {
      "name": "Receive Alert",
      "type": "n8n-nodes-base.webhook"
    },
    {
      "name": "Analyze Alert Severity",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
const alert = items[0].json;
const severity = alert.labels.severity;
const service = alert.labels.service;
const metric = alert.labels.alertname;

// 서비스 중요도 매트릭스
const servicePriority = {
  'payment-service': 'P0',
  'user-service': 'P1',
  'notification-service': 'P2',
  'analytics-service': 'P3'
};

// 메트릭 중요도
const metricPriority = {
  'HighErrorRate': 'P0',
  'ServiceDown': 'P0',
  'HighLatency': 'P1',
  'HighCPU': 'P2'
};

const finalPriority = Math.min(
  servicePriority[service] || 'P3',
  metricPriority[metric] || 'P3'
);

return [{
  json: {
    ...alert,
    finalSeverity: finalPriority,
    escalationLevel: finalPriority === 'P0' ? 'immediate' : 
                    finalPriority === 'P1' ? 'urgent' : 'normal',
    suppressionKey: service + '_' + metric,
    timestamp: new Date().toISOString()
  }
}];
`
      }
    },
    {
      "name": "Check Suppression",
      "type": "n8n-nodes-base.redis",
      "parameters": {
        "operation": "get",
        "key": "=alert_suppression_{{$json.suppressionKey}}"
      }
    },
    {
      "name": "Route to Channels",
      "type": "n8n-nodes-base.switch",
      "parameters": {
        "conditions": [
          {
            "value1": "={{$json.escalationLevel}}",
            "operation": "equal",
            "value2": "immediate"
          },
          {
            "value1": "={{$json.escalationLevel}}",
            "operation": "equal",
            "value2": "urgent"
          }
        ]
      }
    }
  ]
}
                    </div>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>심각도</th>
                            <th>대상</th>
                            <th>채널</th>
                            <th>에스컬레이션 시간</th>
                            <th>자동 대응</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>P0 (Critical)</td>
                            <td>온콜 엔지니어, 매니저</td>
                            <td>전화, SMS, Slack</td>
                            <td>5분</td>
                            <td>자동 복구 시도</td>
                        </tr>
                        <tr>
                            <td>P1 (High)</td>
                            <td>운영팀, 개발팀</td>
                            <td>Slack, 이메일</td>
                            <td>15분</td>
                            <td>워크플로우 트리거</td>
                        </tr>
                        <tr>
                            <td>P2 (Medium)</td>
                            <td>운영팀</td>
                            <td>Slack</td>
                            <td>1시간</td>
                            <td>로그 수집</td>
                        </tr>
                        <tr>
                            <td>P3 (Low)</td>
                            <td>운영팀</td>
                            <td>이메일</td>
                            <td>4시간</td>
                            <td>이슈 티켓 생성</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="alert alert-danger">
                    <strong>⚠️ 알림 피로도 방지:</strong> 동일한 알림이 5분 내에 3회 이상 발생하면 자동으로 억제되며,
                    문제 해결 시까지 30분 간격으로 상태 업데이트만 전송됩니다.
                </div>
            </section>
            
            <section id="dashboards" class="section">
                <h2>📊 대시보드 구성</h2>
                
                <h3>역할 기반 대시보드</h3>
                <div class="dashboard-preview">
                    <h4>🔧 운영팀 대시보드</h4>
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>시스템 상태</h4>
                            <p>• 전체 서비스 가용성<br>• 인프라 리소스 사용률<br>• 활성 알림 개수</p>
                        </div>
                        <div class="feature-card">
                            <h4>성능 메트릭</h4>
                            <p>• 응답시간 추이<br>• 처리량 그래프<br>• 에러율 현황</p>
                        </div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <h4>Grafana 대시보드 자동 생성</h4>
                    <div class="code-block">
// n8n으로 Grafana 대시보드 자동 생성
{
  "name": "Auto Dashboard Generator",
  "nodes": [
    {
      "name": "Service Discovery",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "GET",
        "url": "https://consul.company.com/v1/catalog/services"
      }
    },
    {
      "name": "Generate Dashboard JSON",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
const services = Object.keys(items[0].json);
const dashboardTemplate = {
  "dashboard": {
    "id": null,
    "title": "Auto-Generated Service Overview",
    "tags": ["automated", "overview"],
    "timezone": "browser",
    "panels": [],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
};

let panelId = 1;
let yPos = 0;

services.forEach(service => {
  // CPU 사용률 패널
  dashboardTemplate.dashboard.panels.push({
    "id": panelId++,
    "title": service + " CPU Usage",
    "type": "stat",
    "targets": [{
      "expr": 'rate(cpu_usage_seconds_total{service="' + service + '"}[5m]) * 100'
    }],
    "gridPos": {"h": 8, "w": 12, "x": 0, "y": yPos}
  });
  
  // 메모리 사용률 패널
  dashboardTemplate.dashboard.panels.push({
    "id": panelId++,
    "title": service + " Memory Usage",
    "type": "stat",
    "targets": [{
      "expr": 'memory_usage_bytes{service="' + service + '"} / memory_limit_bytes * 100'
    }],
    "gridPos": {"h": 8, "w": 12, "x": 12, "y": yPos}
  });
  
  yPos += 8;
});

return [{json: dashboardTemplate}];
`
      }
    },
    {
      "name": "Create Dashboard",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "POST",
        "url": "https://grafana.company.com/api/dashboards/db",
        "headers": {
          "Authorization": "Bearer {{$credentials.grafana.apiKey}}",
          "Content-Type": "application/json"
        },
        "body": "={{JSON.stringify($json)}}"
      }
    }
  ]
}
                    </div>
                </div>
            </section>
            
            <section id="integration" class="section">
                <h2>🔗 모니터링 도구 통합</h2>
                
                <h3>멀티벤더 통합 전략</h3>
                <p>
                    엔터프라이즈 환경에서는 다양한 모니터링 도구들이 혼재합니다. 
                    n8n을 통해 이들을 중앙에서 통합 관리하고 일관된 인터페이스를 제공할 수 있습니다.
                </p>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>🔍 Observability Stack</h4>
                        <p>• Prometheus + Grafana<br>• ELK Stack (Elasticsearch, Logstash, Kibana)<br>• Jaeger (분산 트레이싱)<br>• OpenTelemetry</p>
                    </div>
                    <div class="feature-card">
                        <h4>☁️ Cloud Native</h4>
                        <p>• AWS CloudWatch<br>• Azure Monitor<br>• GCP Stackdriver<br>• DataDog, New Relic</p>
                    </div>
                    <div class="feature-card">
                        <h4>📱 Communication</h4>
                        <p>• Slack, Microsoft Teams<br>• PagerDuty, OpsGenie<br>• JIRA Service Management<br>• SMS, Voice 게이트웨이</p>
                    </div>
                    <div class="feature-card">
                        <h4>🤖 Intelligence</h4>
                        <p>• 머신러닝 기반 이상 탐지<br>• 예측적 스케일링<br>• 자동 근본 원인 분석<br>• 지능형 알림 필터링</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <h4>통합 데이터 파이프라인</h4>
                    <div class="code-block">
// 다중 소스 메트릭 수집 및 정규화
async function collectUnifiedMetrics() {
  const sources = [
    {
      name: 'prometheus',
      endpoint: 'https://prometheus.company.com/api/v1/query',
      query: 'up{job="node-exporter"}'
    },
    {
      name: 'cloudwatch',
      endpoint: 'aws-cloudwatch',
      metrics: ['CPUUtilization', 'NetworkIn', 'NetworkOut']
    },
    {
      name: 'datadog',
      endpoint: 'https://api.datadoghq.com/api/v1/metrics',
      metrics: ['system.cpu.user', 'system.mem.used']
    }
  ];

  const results = await Promise.all(
    sources.map(async source => {
      try {
        const data = await fetchMetrics(source);
        return normalizeMetrics(data, source.name);
      } catch (error) {
        console.error(`Failed to collect from ${source.name}:`, error);
        return null;
      }
    })
  );

  const unifiedMetrics = results
    .filter(result => result !== null)
    .reduce((acc, metrics) => ({ ...acc, ...metrics }), {});

  return unifiedMetrics;
}

function normalizeMetrics(rawData, sourceName) {
  // 각 소스별 데이터를 공통 형식으로 변환
  const normalized = {};
  
  switch (sourceName) {
    case 'prometheus':
      rawData.data.result.forEach(metric => {
        const key = `${metric.metric.instance}_${metric.metric.__name__}`;
        normalized[key] = {
          value: parseFloat(metric.value[1]),
          timestamp: metric.value[0] * 1000,
          source: 'prometheus',
          labels: metric.metric
        };
      });
      break;
      
    case 'cloudwatch':
      rawData.MetricDataResults.forEach(metric => {
        normalized[metric.Id] = {
          value: metric.Values[0],
          timestamp: metric.Timestamps[0],
          source: 'cloudwatch'
        };
      });
      break;
      
    case 'datadog':
      rawData.series.forEach(series => {
        normalized[series.metric] = {
          value: series.points[0][1],
          timestamp: series.points[0][0] * 1000,
          source: 'datadog',
          tags: series.tags
        };
      });
      break;
  }
  
  return normalized;
}
                    </div>
                </div>
            </section>
            
            <section id="automation" class="section">
                <h2>⚙️ 자동화 워크플로우</h2>
                
                <h3>자가 치유 시스템</h3>
                <p>
                    일반적인 문제들에 대해서는 인간의 개입 없이 자동으로 해결할 수 있는 시스템을 구축합니다.
                    이를 통해 MTTR(Mean Time To Recovery)을 대폭 단축할 수 있습니다.
                </p>
                
                <div class="workflow-step">
                    <h4>자동 복구 시나리오</h4>
                    <div class="code-block">
// 자동 복구 워크플로우 예제
{
  "name": "Auto Recovery Workflow",
  "nodes": [
    {
      "name": "Service Health Check Failed",
      "type": "n8n-nodes-base.webhook"
    },
    {
      "name": "Analyze Failure Type",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
const alert = items[0].json;
const serviceName = alert.labels.service;
const errorType = alert.labels.alertname;

// 복구 전략 매트릭스
const recoveryStrategies = {
  'ServiceDown': 'restart_service',
  'HighMemoryUsage': 'restart_with_more_memory',
  'DatabaseConnectionFailed': 'restart_db_pool',
  'DiskSpaceLow': 'cleanup_logs',
  'HighCPU': 'scale_horizontally'
};

const strategy = recoveryStrategies[errorType] || 'manual_intervention';

return [{
  json: {
    service: serviceName,
    errorType: errorType,
    recoveryStrategy: strategy,
    timestamp: new Date().toISOString(),
    attemptCount: 0,
    maxAttempts: 3
  }
}];
`
      }
    },
    {
      "name": "Execute Recovery Action",
      "type": "n8n-nodes-base.switch",
      "parameters": {
        "conditions": [
          {
            "value1": "={{$json.recoveryStrategy}}",
            "operation": "equal",
            "value2": "restart_service"
          },
          {
            "value1": "={{$json.recoveryStrategy}}",
            "operation": "equal",
            "value2": "scale_horizontally"
          },
          {
            "value1": "={{$json.recoveryStrategy}}",
            "operation": "equal",
            "value2": "cleanup_logs"
          }
        ]
      }
    },
    {
      "name": "Restart Service",
      "type": "n8n-nodes-base.ssh",
      "parameters": {
        "command": "kubectl rollout restart deployment/{{$json.service}}"
      }
    },
    {
      "name": "Scale Horizontally",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "PATCH",
        "url": "https://k8s-api.company.com/apis/apps/v1/namespaces/production/deployments/{{$json.service}}",
        "body": {
          "spec": {
            "replicas": "={{Math.ceil($json.currentReplicas * 1.5)}}"
          }
        }
      }
    },
    {
      "name": "Cleanup Logs",
      "type": "n8n-nodes-base.ssh",
      "parameters": {
        "command": "find /var/log -name '*.log' -mtime +7 -delete"
      }
    },
    {
      "name": "Wait and Verify",
      "type": "n8n-nodes-base.wait",
      "parameters": {
        "amount": 30,
        "unit": "seconds"
      }
    },
    {
      "name": "Health Check",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "GET",
        "url": "https://{{$json.service}}.company.com/health"
      }
    }
  ]
}
                    </div>
                </div>
                
                <div class="alert alert-success">
                    <strong>✅ 자동 복구 성공률:</strong> 구현된 시스템에서 일반적인 장애의 80%가 
                    인간의 개입 없이 자동으로 해결되며, 평균 복구 시간이 15분에서 3분으로 단축되었습니다.
                </div>
            </section>
            
            <section id="escalation" class="section">
                <h2>📞 에스컬레이션 프로세스</h2>
                
                <h3>지능형 에스컬레이션 매트릭스</h3>
                <div class="workflow-step">
                    <h4>동적 온콜 스케줄링</h4>
                    <div class="code-block">
// 온콜 스케줄 및 에스컬레이션 로직
function getOnCallEngineer(severity, service, timeOfDay) {
  const schedule = {
    weekday: {
      primary: ['john.doe', 'jane.smith'],
      secondary: ['mike.johnson', 'sarah.wilson']
    },
    weekend: {
      primary: ['weekend.engineer1', 'weekend.engineer2'],
      secondary: ['escalation.manager']
    }
  };
  
  const isWeekend = [0, 6].includes(new Date().getDay());
  const currentSchedule = isWeekend ? schedule.weekend : schedule.weekday;
  
  // 심각도별 에스컬레이션 경로
  const escalationPaths = {
    P0: {
      immediate: currentSchedule.primary,
      after5min: currentSchedule.secondary,
      after15min: ['engineering.manager', 'cto']
    },
    P1: {
      immediate: currentSchedule.primary,
      after15min: currentSchedule.secondary,
      after1hour: ['engineering.manager']
    }
  };
  
  return escalationPaths[severity] || escalationPaths.P1;
}

// 에스컬레이션 실행
async function executeEscalation(alert, escalationLevel) {
  const contacts = getOnCallEngineer(alert.severity, alert.service);
  const currentLevel = escalationLevel || 'immediate';
  const targetContacts = contacts[currentLevel] || contacts.immediate;
  
  for (const contact of targetContacts) {
    await Promise.all([
      sendSlackMessage(contact, formatAlertMessage(alert)),
      sendSMS(contact, formatSMSAlert(alert)),
      createPagerDutyIncident(alert, contact)
    ]);
  }
  
  // 다음 에스컬레이션 스케줄링
  if (currentLevel === 'immediate' && contacts.after5min) {
    setTimeout(() => {
      checkAndEscalate(alert, 'after5min');
    }, 5 * 60 * 1000); // 5분 후
  }
}
                    </div>
                </div>
                
                <table>
                    <thead>
                        <tr>
                            <th>시간대</th>
                            <th>1차 대응자</th>
                            <th>2차 에스컬레이션</th>
                            <th>최종 에스컬레이션</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>업무시간 (09:00-18:00)</td>
                            <td>운영팀 (5분 내)</td>
                            <td>시니어 엔지니어 (15분 내)</td>
                            <td>엔지니어링 매니저 (30분 내)</td>
                        </tr>
                        <tr>
                            <td>야간 (18:00-09:00)</td>
                            <td>온콜 엔지니어 (즉시)</td>
                            <td>백업 온콜 (10분 내)</td>
                            <td>온콜 매니저 (20분 내)</td>
                        </tr>
                        <tr>
                            <td>주말/휴일</td>
                            <td>주말 온콜 (즉시)</td>
                            <td>에스컬레이션 매니저 (15분 내)</td>
                            <td>CTO (P0만, 30분 내)</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <section id="maintenance" class="section">
                <h2>🔧 예방적 유지관리</h2>
                
                <h3>예측적 모니터링</h3>
                <p>
                    머신러닝을 활용하여 과거 패턴을 분석하고 미래의 문제를 예측하는 시스템을 구축합니다.
                    이를 통해 장애가 발생하기 전에 사전 조치를 취할 수 있습니다.
                </p>
                
                <div class="workflow-step">
                    <h4>용량 계획 자동화</h4>
                    <div class="code-block">
// 예측적 스케일링 워크플로우
{
  "name": "Predictive Scaling",
  "trigger": {
    "type": "schedule",
    "expression": "0 */15 * * * *"  // 15분마다 실행
  },
  "nodes": [
    {
      "name": "Collect Historical Data",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
// 최근 7일간의 메트릭 데이터 수집
const endTime = new Date();
const startTime = new Date(endTime.getTime() - 7 * 24 * 60 * 60 * 1000);

const query = \`
  avg_over_time(cpu_usage_percent[1h]) and
  avg_over_time(memory_usage_percent[1h]) and
  avg_over_time(request_rate[1h])
\`;

return [{
  json: {
    query: query,
    start: startTime.toISOString(),
    end: endTime.toISOString(),
    step: '1h'
  }
}];
`
      }
    },
    {
      "name": "Fetch Prometheus Data",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "GET",
        "url": "https://prometheus.company.com/api/v1/query_range",
        "qs": {
          "query": "={{$json.query}}",
          "start": "={{$json.start}}",
          "end": "={{$json.end}}",
          "step": "={{$json.step}}"
        }
      }
    },
    {
      "name": "Predict Future Load",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
// 단순 선형 회귀를 사용한 트렌드 예측
function predictTrend(dataPoints) {
  const n = dataPoints.length;
  const sumX = dataPoints.reduce((sum, point, index) => sum + index, 0);
  const sumY = dataPoints.reduce((sum, point) => sum + point.value, 0);
  const sumXY = dataPoints.reduce((sum, point, index) => sum + index * point.value, 0);
  const sumXX = dataPoints.reduce((sum, point, index) => sum + index * index, 0);
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  // 24시간 후 예측값
  const futureX = n + 24;  // 24시간 후
  const prediction = slope * futureX + intercept;
  
  return {
    currentValue: dataPoints[dataPoints.length - 1].value,
    predictedValue: prediction,
    trend: slope > 0 ? 'increasing' : 'decreasing',
    confidence: calculateConfidence(dataPoints, slope, intercept)
  };
}

const metricsData = items[0].json.data.result;
const predictions = {};

metricsData.forEach(metric => {
  const serviceName = metric.metric.service;
  const metricName = metric.metric.__name__;
  
  predictions[\`\${serviceName}_\${metricName}\`] = predictTrend(
    metric.values.map(([timestamp, value]) => ({
      timestamp: parseInt(timestamp),
      value: parseFloat(value)
    }))
  );
});

return [{ json: predictions }];
`
      }
    },
    {
      "name": "Generate Scaling Recommendations",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": `
const predictions = items[0].json;
const recommendations = [];

Object.entries(predictions).forEach(([key, prediction]) => {
  const [service, metric] = key.split('_');
  
  // CPU 사용률이 80% 이상으로 예측되면 스케일 업 권장
  if (metric === 'cpu_usage_percent' && prediction.predictedValue > 80) {
    recommendations.push({
      service: service,
      action: 'scale_up',
      reason: \`CPU usage predicted to reach \${prediction.predictedValue.toFixed(1)}%\`,
      urgency: prediction.predictedValue > 90 ? 'high' : 'medium',
      estimatedTime: '24 hours'
    });
  }
  
  // 메모리 사용률 체크
  if (metric === 'memory_usage_percent' && prediction.predictedValue > 85) {
    recommendations.push({
      service: service,
      action: 'increase_memory',
      reason: \`Memory usage predicted to reach \${prediction.predictedValue.toFixed(1)}%\`,
      urgency: prediction.predictedValue > 95 ? 'high' : 'medium',
      estimatedTime: '24 hours'
    });
  }
});

return [{ json: { recommendations, timestamp: new Date().toISOString() }}];
`
      }
    }
  ]
}
                    </div>
                </div>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>📊 트렌드 분석</h4>
                        <p>• 리소스 사용량 추세 분석<br>• 계절성 패턴 식별<br>• 비정상 증가율 탐지<br>• 용량 한계 도달 예측</p>
                    </div>
                    <div class="feature-card">
                        <h4>🎯 사전 대응</h4>
                        <p>• 자동 스케일링 권장<br>• 리소스 프로비저닝 계획<br>• 유지보수 창 스케줄링<br>• 비용 최적화 제안</p>
                    </div>
                </div>
            </section>
            
            <section id="case-studies" class="section">
                <h2>💼 실제 구현 사례</h2>
                
                <h3>사례 1: 대형 온라인 쇼핑몰</h3>
                <div class="feature-card" style="background: linear-gradient(135deg, #a8e6cf 0%, #88d8a3 100%);">
                    <h4>🎯 도전 과제</h4>
                    <ul>
                        <li>블랙 프라이데이, 사이버 먼데이 등 트래픽 급증 이벤트 대응</li>
                        <li>300개 이상의 마이크로서비스 모니터링</li>
                        <li>글로벌 다중 리전 서비스 운영</li>
                        <li>99.99% SLA 달성 요구</li>
                    </ul>
                    
                    <h4>💡 n8n 솔루션</h4>
                    <ul>
                        <li><strong>예측적 스케일링:</strong> 과거 이벤트 데이터를 기반으로 트래픽 증가 예측 및 사전 리소스 확보</li>
                        <li><strong>지역별 라우팅:</strong> 리전별 성능 모니터링 및 자동 트래픽 라우팅</li>
                        <li><strong>실시간 알림:</strong> 카테고리별 담당자에게 즉시 알림 전송</li>
                        <li><strong>자동 복구:</strong> 일반적인 장애 시나리오에 대한 자동 해결</li>
                    </ul>
                    
                    <h4>📈 달성 결과</h4>
                    <ul>
                        <li>이벤트 기간 중 시스템 가용성 99.99% 달성</li>
                        <li>평균 복구 시간 85% 단축 (20분 → 3분)</li>
                        <li>인프라 비용 30% 절감 (효율적인 리소스 관리)</li>
                        <li>고객 만족도 95% 이상 유지</li>
                    </ul>
                </div>
                
                <h3>사례 2: 금융 서비스 기관</h3>
                <div class="feature-card" style="background: linear-gradient(135deg, #ffd3a5 0%, #fd9853 100%);">
                    <h4>🎯 도전 과제</h4>
                    <ul>
                        <li>금융 규제 준수를 위한 상세한 감사 로그 요구</li>
                        <li>실시간 거래 처리 시스템의 고가용성 보장</li>
                        <li>보안 침해 탐지 및 즉시 대응</li>
                        <li>레거시 시스템과 현대적 모니터링 도구 통합</li>
                    </ul>
                    
                    <h4>💡 n8n 솔루션</h4>
                    <ul>
                        <li><strong>컴플라이언스 모니터링:</strong> 모든 시스템 변경 사항 자동 로깅 및 보고</li>
                        <li><strong>보안 이벤트 대응:</strong> 의심스러운 활동 탐지 시 자동 격리 및 알림</li>
                        <li><strong>거래 모니터링:</strong> 거래량, 응답시간, 에러율 실시간 추적</li>
                        <li><strong>레거시 통합:</strong> 메인프레임과 현대적 시스템 간 데이터 브리지</li>
                    </ul>
                    
                    <h4>📈 달성 결과</h4>
                    <ul>
                        <li>보안 인시던트 대응 시간 90% 단축 (2시간 → 12분)</li>
                        <li>규제 감사 통과율 100% 달성</li>
                        <li>거래 시스템 가용성 99.999% 달성</li>
                        <li>운영 인력 40% 절감 및 효율성 증대</li>
                    </ul>
                </div>
                
                <div class="alert alert-success">
                    <strong>🎉 핵심 성공 요인:</strong> 두 사례 모두 n8n의 뛰어난 통합 능력과 유연한 워크플로우를 
                    활용하여 기존 도구들을 효과적으로 연결하고, 인간의 판단이 필요한 부분과 자동화 가능한 부분을 
                    명확히 구분한 것이 성공의 핵심이었습니다.
                </div>
            </section>
        </main>
    </div>
    
    <script>
        // 부드러운 스크롤 효과
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                
                if (targetSection) {
                    targetSection.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // 활성 링크 업데이트
                    document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
                    this.classList.add('active');
                }
            });
        });
        
        // 스크롤 시 사이드바 활성 링크 업데이트
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const scrollPosition = window.scrollY + 100;
            
            sections.forEach(section => {
                const top = section.offsetTop;
                const height = section.offsetHeight;
                const id = section.getAttribute('id');
                
                if (scrollPosition >= top && scrollPosition < top + height) {
                    document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
                    document.querySelector(`.sidebar a[href="#${id}"]`)?.classList.add('active');
                }
            });
        });
        
        // 메트릭 카드 애니메이션
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.transform = 'translateY(0)';
                    entry.target.style.opacity = '1';
                }
            });
        });
        
        document.querySelectorAll('.metric-card').forEach(card => {
            card.style.transform = 'translateY(20px)';
            card.style.opacity = '0';
            card.style.transition = 'all 0.5s ease-out';
            observer.observe(card);
        });
    </script>
</body>
</html>