<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n8n CI/CD 파이프라인 자동화 - 엔터프라이즈 가이드</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
        }
        
        .container {
            display: flex;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 4px 0 15px rgba(0,0,0,0.1);
        }
        
        .sidebar h2 {
            color: white;
            font-size: 1.4em;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        
        .sidebar ul {
            list-style: none;
        }
        
        .sidebar li {
            margin-bottom: 15px;
        }
        
        .sidebar a {
            color: rgba(255,255,255,0.9);
            text-decoration: none;
            display: block;
            padding: 12px 15px;
            border-radius: 8px;
            transition: all 0.3s;
            background: rgba(255,255,255,0.05);
        }
        
        .sidebar a:hover {
            background: rgba(255,255,255,0.15);
            transform: translateX(5px);
        }
        
        .sidebar .active {
            background: rgba(255,255,255,0.2);
            font-weight: bold;
        }
        
        .main-content {
            margin-left: 280px;
            width: calc(100% - 280px);
            padding: 40px;
            background: white;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 60px 40px;
            border-radius: 15px;
            margin-bottom: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 20px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }
        
        .section {
            background: white;
            padding: 40px;
            margin-bottom: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            border-left: 5px solid #667eea;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e6ed;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .code-block {
            background: #1e2936;
            color: #e0e6ed;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .workflow-step {
            background: #f8f9fa;
            padding: 25px;
            margin: 20px 0;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .workflow-step h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }
        
        .feature-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #e9ecef 100%);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #dee2e6;
            transition: all 0.3s;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        
        .feature-card h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .alert {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .alert-info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }
        
        .alert-success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .implementation-steps {
            counter-reset: step-counter;
            margin: 30px 0;
        }
        
        .implementation-steps li {
            counter-increment: step-counter;
            margin-bottom: 20px;
            padding-left: 50px;
            position: relative;
            list-style: none;
        }
        
        .implementation-steps li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #667eea;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2>🔧 n8n 자동화 가이드</h2>
            <ul>
                <li><a href="#overview" class="active">개요</a></li>
                <li><a href="#architecture">아키텍처 설계</a></li>
                <li><a href="#implementation">구현 방법</a></li>
                <li><a href="#workflow">워크플로우 구성</a></li>
                <li><a href="#integration">시스템 통합</a></li>
                <li><a href="#monitoring">모니터링 설정</a></li>
                <li><a href="#security">보안 고려사항</a></li>
                <li><a href="#best-practices">베스트 프랙티스</a></li>
                <li><a href="#troubleshooting">문제 해결</a></li>
                <li><a href="#case-studies">실제 사례</a></li>
            </ul>
        </aside>
        
        <main class="main-content">
            <div class="header">
                <h1>CI/CD 파이프라인 자동화</h1>
                <p>n8n을 활용한 엔터프라이즈급 지속적 통합/배포 자동화 완벽 가이드</p>
            </div>
            
            <section id="overview" class="section">
                <h2>📋 개요 및 비즈니스 가치</h2>
                <p>
                    CI/CD 파이프라인 자동화는 현대 소프트웨어 개발의 핵심입니다. n8n을 통해 GitHub, GitLab, Jenkins, Docker, Kubernetes 등 
                    다양한 도구들을 통합하여 완전 자동화된 배포 파이프라인을 구축할 수 있습니다. 이는 개발 속도를 획기적으로 향상시키고,
                    인적 오류를 최소화하며, 일관된 배포 프로세스를 보장합니다.
                </p>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>🚀 자동 빌드 및 테스트</h4>
                        <p>코드 커밋 시 자동으로 빌드하고 단위 테스트, 통합 테스트를 실행합니다. 테스트 실패 시 즉시 개발팀에 알림을 전송합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>🔍 코드 품질 검사</h4>
                        <p>SonarQube와 연동하여 코드 품질을 자동으로 분석하고, 보안 취약점을 사전에 탐지합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>📦 컨테이너 이미지 관리</h4>
                        <p>Docker 이미지를 자동으로 빌드하고 레지스트리에 푸시합니다. 버전 태깅과 이미지 스캔을 자동화합니다.</p>
                    </div>
                    <div class="feature-card">
                        <h4>☸️ Kubernetes 배포</h4>
                        <p>검증된 이미지를 Kubernetes 클러스터에 자동 배포하고, 롤링 업데이트와 롤백을 관리합니다.</p>
                    </div>
                </div>
            </section>
            
            <section id="architecture" class="section">
                <h2>🏗️ 아키텍처 설계</h2>
                
                <h3>시스템 구성 요소</h3>
                <p>
                    엔터프라이즈급 CI/CD 파이프라인은 다음과 같은 구성 요소들로 이루어집니다. n8n은 이들을 중앙에서 
                    오케스트레이션하는 역할을 수행합니다.
                </p>
                
                <table>
                    <thead>
                        <tr>
                            <th>구성 요소</th>
                            <th>역할</th>
                            <th>연동 방식</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Git Repository</td>
                            <td>소스 코드 버전 관리</td>
                            <td>Webhook, API</td>
                        </tr>
                        <tr>
                            <td>Build Server</td>
                            <td>코드 컴파일 및 패키징</td>
                            <td>SSH, REST API</td>
                        </tr>
                        <tr>
                            <td>Test Environment</td>
                            <td>자동화 테스트 실행</td>
                            <td>HTTP Request</td>
                        </tr>
                        <tr>
                            <td>Container Registry</td>
                            <td>Docker 이미지 저장소</td>
                            <td>Docker API</td>
                        </tr>
                        <tr>
                            <td>Kubernetes Cluster</td>
                            <td>애플리케이션 배포 및 운영</td>
                            <td>kubectl, API</td>
                        </tr>
                        <tr>
                            <td>Monitoring System</td>
                            <td>배포 상태 모니터링</td>
                            <td>Prometheus API</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="alert alert-info">
                    <strong>💡 아키텍처 설계 팁:</strong> 마이크로서비스 환경에서는 각 서비스별로 독립적인 파이프라인을 구성하되, 
                    공통 워크플로우는 재사용 가능한 서브워크플로우로 모듈화하는 것이 효과적입니다.
                </div>
            </section>
            
            <section id="implementation" class="section">
                <h2>⚙️ 구현 방법</h2>
                
                <h3>1단계: n8n 환경 설정</h3>
                <div class="workflow-step">
                    <h4>Docker Compose를 통한 n8n 설치</h4>
                    <div class="code-block">
version: '3.8'
services:
  n8n:
    image: n8nio/n8n:latest
    restart: always
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=your-secure-password
      - N8N_HOST=your-domain.com
      - N8N_PROTOCOL=https
      - N8N_PORT=5678
      - WEBHOOK_URL=https://your-domain.com/
      - GENERIC_TIMEZONE=Asia/Seoul
    volumes:
      - n8n_data:/home/node/.n8n
      - ./local-files:/files
    networks:
      - n8n-network

  postgres:
    image: postgres:13
    restart: always
    environment:
      - POSTGRES_USER=n8n
      - POSTGRES_PASSWORD=n8n
      - POSTGRES_DB=n8n
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - n8n-network

volumes:
  n8n_data:
  postgres_data:

networks:
  n8n-network:
    driver: bridge
                    </div>
                </div>
                
                <h3>2단계: GitHub Webhook 설정</h3>
                <div class="workflow-step">
                    <h4>Repository Webhook 구성</h4>
                    <ol class="implementation-steps">
                        <li>GitHub Repository Settings에서 Webhooks 메뉴 접근</li>
                        <li>Payload URL에 n8n Webhook URL 입력: https://your-n8n.com/webhook/github-push</li>
                        <li>Content type을 application/json으로 설정</li>
                        <li>Secret token 생성 및 저장 (보안 강화)</li>
                        <li>이벤트 선택: Push, Pull Request, Release</li>
                    </ol>
                </div>
                
                <h3>3단계: 빌드 프로세스 자동화</h3>
                <div class="code-block">
{
  "nodes": [
    {
      "name": "GitHub Webhook",
      "type": "n8n-nodes-base.webhook",
      "parameters": {
        "path": "github-push",
        "responseMode": "onReceived",
        "responseData": "allEntries"
      }
    },
    {
      "name": "Parse Commit Info",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "const payload = items[0].json.body;\nreturn [{\n  json: {\n    repository: payload.repository.name,\n    branch: payload.ref.split('/').pop(),\n    commit: payload.head_commit.id,\n    author: payload.head_commit.author.name,\n    message: payload.head_commit.message,\n    timestamp: payload.head_commit.timestamp\n  }\n}];"
      }
    },
    {
      "name": "Trigger Jenkins Build",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "POST",
        "url": "https://jenkins.company.com/job/{{$json.repository}}/buildWithParameters",
        "authentication": "basicAuth",
        "queryParameters": {
          "parameters": [
            {
              "name": "BRANCH",
              "value": "={{$json.branch}}"
            },
            {
              "name": "COMMIT_ID",
              "value": "={{$json.commit}}"
            }
          ]
        }
      }
    }
  ]
}
                </div>
            </section>
            
            <section id="workflow" class="section">
                <h2>🔄 워크플로우 구성</h2>
                
                <h3>메인 CI/CD 워크플로우</h3>
                <p>
                    완전한 CI/CD 파이프라인은 다음과 같은 단계로 구성됩니다. 각 단계는 n8n의 노드로 구현되며,
                    조건부 분기와 에러 처리를 통해 안정적인 자동화를 보장합니다.
                </p>
                
                <div class="workflow-step">
                    <h4>Stage 1: 소스 코드 체크아웃 및 검증</h4>
                    <div class="code-block">
// Git Clone 및 브랜치 검증
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

async function cloneRepository() {
  const repoUrl = $input.item.json.repository_url;
  const branch = $input.item.json.branch;
  const workspace = `/tmp/workspace/${Date.now()}`;
  
  // Repository 클론
  await execPromise(`git clone -b ${branch} ${repoUrl} ${workspace}`);
  
  // 커밋 검증
  const { stdout } = await execPromise(`cd ${workspace} && git log -1 --format=%H`);
  
  return {
    workspace: workspace,
    commitHash: stdout.trim(),
    status: 'success'
  };
}

return await cloneRepository();
                    </div>
                </div>
                
                <div class="workflow-step">
                    <h4>Stage 2: 빌드 및 테스트</h4>
                    <div class="code-block">
// Docker 빌드 및 테스트 실행
{
  "buildStage": {
    "dockerfile": "./Dockerfile",
    "context": "{{$json.workspace}}",
    "tags": [
      "{{$json.repository}}:{{$json.commitHash}}",
      "{{$json.repository}}:latest"
    ],
    "buildArgs": {
      "NODE_ENV": "production",
      "BUILD_DATE": "{{$now.toISO()}}",
      "VCS_REF": "{{$json.commitHash}}"
    }
  },
  "testStage": {
    "testCommand": "npm test",
    "coverageThreshold": 80,
    "timeout": 300000
  }
}
                    </div>
                </div>
                
                <div class="workflow-step">
                    <h4>Stage 3: 이미지 스캔 및 레지스트리 푸시</h4>
                    <div class="code-block">
// Trivy를 이용한 보안 스캔
async function scanAndPushImage() {
  const imageName = `${$json.repository}:${$json.commitHash}`;
  
  // 보안 스캔 실행
  const scanResult = await execPromise(
    `trivy image --severity HIGH,CRITICAL --format json ${imageName}`
  );
  
  const vulnerabilities = JSON.parse(scanResult.stdout);
  
  if (vulnerabilities.Results.some(r => r.Vulnerabilities?.length > 0)) {
    // 심각한 취약점 발견 시 알림
    await sendSlackNotification({
      channel: '#security',
      text: `🚨 Critical vulnerabilities found in ${imageName}`,
      attachments: vulnerabilities.Results
    });
    
    if (process.env.BLOCK_ON_VULNERABILITIES === 'true') {
      throw new Error('Critical vulnerabilities detected');
    }
  }
  
  // 레지스트리 푸시
  await execPromise(`docker push ${imageName}`);
  
  return {
    image: imageName,
    scanStatus: 'completed',
    vulnerabilityCount: vulnerabilities.Results.length
  };
}
                    </div>
                </div>
            </section>
            
            <section id="integration" class="section">
                <h2>🔗 시스템 통합</h2>
                
                <h3>Jenkins 연동</h3>
                <div class="workflow-step">
                    <h4>Jenkins Job 트리거 및 모니터링</h4>
                    <p>
                        n8n에서 Jenkins API를 활용하여 빌드 작업을 트리거하고 실시간으로 상태를 모니터링합니다.
                        빌드 실패 시 자동으로 롤백 프로세스를 시작하고 관련 팀에 알림을 전송합니다.
                    </p>
                    <div class="code-block">
// Jenkins 빌드 모니터링
const jenkinsUrl = 'https://jenkins.company.com';
const jobName = $json.repository;
const buildNumber = $json.buildNumber;

async function monitorBuild() {
  let buildStatus = 'BUILDING';
  let attempts = 0;
  const maxAttempts = 60; // 최대 30분 대기
  
  while (buildStatus === 'BUILDING' && attempts < maxAttempts) {
    const response = await $http.get({
      url: `${jenkinsUrl}/job/${jobName}/${buildNumber}/api/json`,
      auth: {
        username: $credentials.jenkins.username,
        password: $credentials.jenkins.apiToken
      }
    });
    
    buildStatus = response.result;
    
    if (buildStatus === 'BUILDING') {
      await new Promise(resolve => setTimeout(resolve, 30000)); // 30초 대기
      attempts++;
    }
  }
  
  return {
    jobName,
    buildNumber,
    status: buildStatus,
    duration: response.duration,
    url: response.url,
    artifacts: response.artifacts
  };
}
                    </div>
                </div>
                
                <h3>Kubernetes 배포</h3>
                <div class="workflow-step">
                    <h4>Rolling Update 전략</h4>
                    <div class="code-block">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{APP_NAME}}
  namespace: {{NAMESPACE}}
spec:
  replicas: {{REPLICAS}}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: {{APP_NAME}}
  template:
    metadata:
      labels:
        app: {{APP_NAME}}
        version: {{VERSION}}
    spec:
      containers:
      - name: {{APP_NAME}}
        image: {{REGISTRY}}/{{APP_NAME}}:{{VERSION}}
        ports:
        - containerPort: {{PORT}}
        env:
        - name: NODE_ENV
          value: "production"
        livenessProbe:
          httpGet:
            path: /health
            port: {{PORT}}
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: {{PORT}}
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
                    </div>
                </div>
                
                <div class="alert alert-success">
                    <strong>✅ 통합 성공 사례:</strong> 한 금융 기업에서 n8n을 통해 Jenkins, GitLab, Kubernetes, Prometheus를 
                    통합한 결과, 배포 시간이 4시간에서 15분으로 단축되었고, 배포 실패율이 80% 감소했습니다.
                </div>
            </section>
            
            <section id="monitoring" class="section">
                <h2>📊 모니터링 설정</h2>
                
                <h3>실시간 파이프라인 모니터링</h3>
                <p>
                    n8n과 Prometheus, Grafana를 연동하여 CI/CD 파이프라인의 모든 단계를 실시간으로 모니터링하고,
                    이상 징후를 사전에 감지합니다.
                </p>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>📈 메트릭 수집</h4>
                        <ul>
                            <li>빌드 소요 시간</li>
                            <li>테스트 커버리지</li>
                            <li>배포 빈도</li>
                            <li>실패율 및 복구 시간</li>
                            <li>리소스 사용량</li>
                        </ul>
                    </div>
                    <div class="feature-card">
                        <h4>🚨 알림 규칙</h4>
                        <ul>
                            <li>빌드 실패 시 즉시 알림</li>
                            <li>테스트 커버리지 임계값 미달</li>
                            <li>배포 후 에러율 증가</li>
                            <li>리소스 사용량 급증</li>
                            <li>SLA 위반 위험</li>
                        </ul>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <h4>Prometheus 메트릭 수집 설정</h4>
                    <div class="code-block">
// n8n 커스텀 메트릭 익스포터
const promClient = require('prom-client');
const register = new promClient.Registry();

// 커스텀 메트릭 정의
const buildDuration = new promClient.Histogram({
  name: 'cicd_build_duration_seconds',
  help: 'Duration of CI/CD builds in seconds',
  labelNames: ['project', 'branch', 'status'],
  buckets: [30, 60, 120, 300, 600, 1200, 1800, 3600]
});

const deploymentCounter = new promClient.Counter({
  name: 'cicd_deployments_total',
  help: 'Total number of deployments',
  labelNames: ['environment', 'service', 'status']
});

const testCoverage = new promClient.Gauge({
  name: 'cicd_test_coverage_percent',
  help: 'Test coverage percentage',
  labelNames: ['project', 'branch']
});

register.registerMetric(buildDuration);
register.registerMetric(deploymentCounter);
register.registerMetric(testCoverage);

// 메트릭 업데이트
function updateMetrics(buildData) {
  buildDuration.observe(
    { 
      project: buildData.project, 
      branch: buildData.branch, 
      status: buildData.status 
    },
    buildData.duration
  );
  
  if (buildData.deployed) {
    deploymentCounter.inc({
      environment: buildData.environment,
      service: buildData.service,
      status: buildData.deployStatus
    });
  }
  
  testCoverage.set(
    { 
      project: buildData.project, 
      branch: buildData.branch 
    },
    buildData.coverage
  );
}

// Prometheus 엔드포인트 노출
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
});
                    </div>
                </div>
            </section>
            
            <section id="security" class="section">
                <h2>🔐 보안 고려사항</h2>
                
                <h3>시크릿 관리</h3>
                <p>
                    CI/CD 파이프라인에서 사용되는 모든 시크릿과 인증 정보는 안전하게 관리되어야 합니다.
                    n8n의 Credentials 기능과 외부 시크릿 관리 도구를 연동하여 보안을 강화합니다.
                </p>
                
                <div class="workflow-step">
                    <h4>HashiCorp Vault 연동</h4>
                    <div class="code-block">
// Vault에서 시크릿 가져오기
const vault = require('node-vault')({
  endpoint: 'https://vault.company.com',
  token: process.env.VAULT_TOKEN
});

async function getSecrets(path) {
  try {
    const result = await vault.read(path);
    return result.data.data;
  } catch (error) {
    console.error('Failed to retrieve secrets:', error);
    throw new Error('Secret retrieval failed');
  }
}

// 데이터베이스 인증 정보 가져오기
const dbCreds = await getSecrets('secret/data/database/production');

// Docker Registry 인증 정보
const registryCreds = await getSecrets('secret/data/docker/registry');

// API 키 관리
const apiKeys = await getSecrets('secret/data/apis/external');

return {
  database: {
    host: dbCreds.host,
    username: dbCreds.username,
    password: dbCreds.password
  },
  registry: {
    url: registryCreds.url,
    username: registryCreds.username,
    password: registryCreds.password
  },
  apis: apiKeys
};
                    </div>
                </div>
                
                <h3>접근 제어 및 감사</h3>
                <table>
                    <thead>
                        <tr>
                            <th>보안 영역</th>
                            <th>구현 방법</th>
                            <th>모니터링 포인트</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>인증/인가</td>
                            <td>OAuth 2.0, SAML, LDAP 연동</td>
                            <td>로그인 시도, 권한 변경</td>
                        </tr>
                        <tr>
                            <td>네트워크 보안</td>
                            <td>VPN, Private Network, TLS 1.3</td>
                            <td>비정상 트래픽, 포트 스캔</td>
                        </tr>
                        <tr>
                            <td>코드 보안</td>
                            <td>SAST, DAST, 의존성 스캔</td>
                            <td>취약점 발견, 패치 상태</td>
                        </tr>
                        <tr>
                            <td>컨테이너 보안</td>
                            <td>이미지 스캔, 런타임 보호</td>
                            <td>CVE 발견, 비정상 동작</td>
                        </tr>
                        <tr>
                            <td>감사 로깅</td>
                            <td>중앙화된 로그 수집, SIEM</td>
                            <td>모든 변경사항, 접근 기록</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <section id="best-practices" class="section">
                <h2>⭐ 베스트 프랙티스</h2>
                
                <h3>파이프라인 최적화 전략</h3>
                <ol class="implementation-steps">
                    <li>
                        <strong>병렬 처리 활용:</strong> 독립적인 작업들은 병렬로 실행하여 전체 파이프라인 시간을 단축합니다.
                        n8n의 Split In Batches 노드를 활용하여 대량 작업을 효율적으로 처리합니다.
                    </li>
                    <li>
                        <strong>캐싱 전략:</strong> Docker 레이어 캐싱, 의존성 캐싱을 통해 빌드 시간을 최소화합니다.
                        자주 변경되지 않는 부분은 별도 레이어로 분리합니다.
                    </li>
                    <li>
                        <strong>점진적 롤아웃:</strong> Canary 배포, Blue-Green 배포를 통해 위험을 최소화하면서 
                        새 버전을 배포합니다.
                    </li>
                    <li>
                        <strong>자동 롤백:</strong> 배포 후 헬스체크 실패 시 자동으로 이전 버전으로 롤백하는 
                        메커니즘을 구현합니다.
                    </li>
                    <li>
                        <strong>환경별 구성 관리:</strong> 개발, 스테이징, 프로덕션 환경별로 별도의 구성을 관리하고,
                        환경 변수를 통해 동적으로 설정을 주입합니다.
                    </li>
                </ol>
                
                <div class="alert">
                    <strong>⚠️ 주의사항:</strong> 프로덕션 배포는 항상 승인 프로세스를 거치도록 설정하고,
                    중요한 변경사항은 Change Advisory Board(CAB)의 검토를 받도록 합니다.
                </div>
            </section>
            
            <section id="troubleshooting" class="section">
                <h2>🔧 문제 해결</h2>
                
                <h3>일반적인 문제와 해결 방법</h3>
                
                <div class="workflow-step">
                    <h4>문제: 빌드 시간 초과</h4>
                    <p><strong>원인:</strong> 대용량 의존성, 비효율적인 Dockerfile, 네트워크 지연</p>
                    <p><strong>해결책:</strong></p>
                    <ul>
                        <li>멀티스테이지 빌드 사용</li>
                        <li>의존성 캐싱 레이어 최적화</li>
                        <li>병렬 빌드 작업 구성</li>
                        <li>빌드 서버 리소스 증설</li>
                    </ul>
                </div>
                
                <div class="workflow-step">
                    <h4>문제: 간헐적인 테스트 실패</h4>
                    <p><strong>원인:</strong> 테스트 간 의존성, 타이밍 이슈, 외부 서비스 의존</p>
                    <p><strong>해결책:</strong></p>
                    <ul>
                        <li>테스트 격리 강화</li>
                        <li>Mock 서비스 활용</li>
                        <li>재시도 로직 구현</li>
                        <li>테스트 환경 초기화</li>
                    </ul>
                </div>
                
                <div class="workflow-step">
                    <h4>문제: 배포 후 서비스 장애</h4>
                    <p><strong>원인:</strong> 설정 오류, 호환성 문제, 리소스 부족</p>
                    <p><strong>해결책:</strong></p>
                    <div class="code-block">
// 자동 롤백 스크립트
async function autoRollback() {
  const healthCheckUrl = 'https://api.company.com/health';
  const maxRetries = 5;
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      const response = await fetch(healthCheckUrl);
      if (response.status === 200) {
        console.log('Health check passed');
        return { status: 'success' };
      }
    } catch (error) {
      console.error(`Health check failed: ${error.message}`);
    }
    
    retries++;
    await new Promise(resolve => setTimeout(resolve, 10000));
  }
  
  // 롤백 실행
  console.log('Initiating rollback...');
  await kubectl('rollout undo deployment/api-server');
  
  // 알림 전송
  await sendAlert({
    severity: 'critical',
    message: 'Automatic rollback initiated due to health check failures',
    service: 'api-server'
  });
  
  return { status: 'rollback' };
}
                    </div>
                </div>
            </section>
            
            <section id="case-studies" class="section">
                <h2>💼 실제 사례 연구</h2>
                
                <h3>사례 1: 글로벌 이커머스 플랫폼</h3>
                <div class="feature-card">
                    <h4>도전 과제</h4>
                    <ul>
                        <li>일일 100회 이상의 배포 요구</li>
                        <li>20개 이상의 마이크로서비스 관리</li>
                        <li>다중 지역 배포 조정</li>
                        <li>99.99% 가용성 SLA 준수</li>
                    </ul>
                    
                    <h4>n8n 솔루션</h4>
                    <ul>
                        <li>서비스별 독립 파이프라인 구성</li>
                        <li>지역별 순차 배포 자동화</li>
                        <li>실시간 모니터링 대시보드</li>
                        <li>자동 스케일링 및 롤백</li>
                    </ul>
                    
                    <h4>결과</h4>
                    <ul>
                        <li>배포 시간 85% 단축 (2시간 → 18분)</li>
                        <li>배포 실패율 92% 감소</li>
                        <li>평균 복구 시간(MTTR) 75% 개선</li>
                        <li>개발자 생산성 3배 향상</li>
                    </ul>
                </div>
                
                <h3>사례 2: 금융 서비스 기업</h3>
                <div class="feature-card">
                    <h4>도전 과제</h4>
                    <ul>
                        <li>엄격한 규제 준수 요구사항</li>
                        <li>복잡한 승인 프로세스</li>
                        <li>레거시 시스템과의 통합</li>
                        <li>감사 추적 의무화</li>
                    </ul>
                    
                    <h4>n8n 솔루션</h4>
                    <ul>
                        <li>다단계 승인 워크플로우</li>
                        <li>자동화된 컴플라이언스 검사</li>
                        <li>상세한 감사 로그 생성</li>
                        <li>레거시 API 어댑터 구현</li>
                    </ul>
                    
                    <h4>결과</h4>
                    <ul>
                        <li>규제 준수 비용 60% 절감</li>
                        <li>감사 준비 시간 90% 단축</li>
                        <li>보안 인시던트 0건 달성</li>
                        <li>변경 관리 프로세스 자동화 100%</li>
                    </ul>
                </div>
                
                <div class="alert alert-success">
                    <strong>🎯 핵심 성공 요인:</strong> n8n의 유연한 워크플로우 엔진과 다양한 통합 옵션을 활용하여
                    각 기업의 고유한 요구사항에 맞춘 맞춤형 CI/CD 파이프라인을 구축할 수 있었습니다.
                </div>
            </section>
        </main>
    </div>
    
    <script>
        // 부드러운 스크롤 효과
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const targetSection = document.getElementById(targetId);
                
                if (targetSection) {
                    targetSection.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    
                    // 활성 링크 업데이트
                    document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
                    this.classList.add('active');
                }
            });
        });
        
        // 스크롤 시 사이드바 활성 링크 업데이트
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const scrollPosition = window.scrollY + 100;
            
            sections.forEach(section => {
                const top = section.offsetTop;
                const height = section.offsetHeight;
                const id = section.getAttribute('id');
                
                if (scrollPosition >= top && scrollPosition < top + height) {
                    document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
                    document.querySelector(`.sidebar a[href="#${id}"]`)?.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>