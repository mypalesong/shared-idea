<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제2장: 함수형 프로그래밍 (Functional Programming)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Times New Roman', Georgia, serif;
            line-height: 1.8;
            color: #333;
            background-color: #fafafa;
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .chapter {
            background-color: white;
            padding: 50px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chapter-header {
            text-align: center;
            border-bottom: 3px solid #8e44ad;
            padding-bottom: 20px;
            margin-bottom: 40px;
        }
        
        .chapter-number {
            color: #e74c3c;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .chapter-title {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .chapter-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            font-style: italic;
        }
        
        h2 {
            color: #8e44ad;
            font-size: 1.8em;
            margin: 30px 0 20px 0;
            border-left: 5px solid #9b59b6;
            padding-left: 15px;
        }
        
        h3 {
            color: #27ae60;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }
        
        .definition-box {
            background: linear-gradient(135deg, #f3e7f7, #faf0fd);
            border-left: 5px solid #9b59b6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .definition-title {
            color: #8e44ad;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .concept-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .principles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .principle-card {
            background: #fff;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .principle-title {
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .advantages {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
        }
        
        .disadvantages {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
        }
        
        .real-world-example {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background-color: #8e44ad;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        ul, ol {
            padding-left: 30px;
            margin: 15px 0;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .summary-box {
            background: #e9ecef;
            border: 2px solid #6c757d;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }
        
        .summary-title {
            color: #495057;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .immutable-example {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="chapter">
        <div class="chapter-header">
            <div class="chapter-number">제2장</div>
            <h1 class="chapter-title">함수형 프로그래밍</h1>
            <div class="chapter-subtitle">Functional Programming</div>
        </div>

        <div class="definition-box">
            <div class="definition-title">정의</div>
            <p>함수형 프로그래밍(Functional Programming, FP)은 계산을 수학적 함수의 평가로 취급하고 상태 변경과 변경 가능한 데이터를 피하는 프로그래밍 패러다임입니다. 함수를 일급 객체로 다루며, 부작용(side effects)을 최소화하여 프로그램의 예측 가능성과 안정성을 높입니다.</p>
        </div>

        <h2>2.1 함수형 프로그래밍의 핵심 개념</h2>

        <div class="principles-grid">
            <div class="principle-card">
                <div class="principle-title">순수 함수 (Pure Functions)</div>
                <p>동일한 입력에 대해 항상 동일한 출력을 반환하며, 부작용이 없는 함수입니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">불변성 (Immutability)</div>
                <p>데이터가 한번 생성된 후에는 변경되지 않는 특성으로, 상태 변경으로 인한 버그를 방지합니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">고차 함수 (Higher-Order Functions)</div>
                <p>함수를 인자로 받거나 함수를 반환하는 함수로, 코드의 재사용성과 추상화를 높입니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">선언적 프로그래밍 (Declarative Programming)</div>
                <p>"어떻게"보다는 "무엇을"에 초점을 맞춘 프로그래밍 스타일입니다.</p>
            </div>
        </div>

        <h2>2.2 순수 함수와 부작용</h2>

        <h3>순수 함수의 특징</h3>
        <div class="concept-box">
            <p>순수 함수는 다음 조건을 만족해야 합니다:</p>
            <ul>
                <li>동일한 입력에 대해 항상 동일한 출력</li>
                <li>외부 상태를 변경하지 않음</li>
                <li>외부 상태에 의존하지 않음</li>
                <li>예외를 발생시키지 않음</li>
            </ul>
        </div>

        <div class="code-example">
// 순수 함수 예제
const add = (a, b) => a + b;  // 항상 같은 입력에 같은 출력
const multiply = (x, y) => x * y;

// 비순수 함수 예제
let counter = 0;
const incrementCounter = () => {
    counter++;  // 외부 상태 변경
    return counter;
};

const getCurrentTime = () => new Date();  // 외부 환경에 의존

// 순수 함수로 변환
const increment = (value) => value + 1;
const formatTime = (timestamp) => new Date(timestamp).toISOString();
        </div>

        <h3>함수 합성 (Function Composition)</h3>
        <p>작은 함수들을 조합하여 복잡한 기능을 구현하는 기법입니다.</p>

        <div class="code-example">
// 함수 합성 예제
const compose = (f, g) => (x) => f(g(x));

const addOne = (x) => x + 1;
const multiplyByTwo = (x) => x * 2;
const square = (x) => x * x;

const composedFunction = compose(
    compose(square, multiplyByTwo),
    addOne
);

console.log(composedFunction(3)); // (3 + 1) * 2 = 8, 8^2 = 64

// 파이프라인 스타일
const pipe = (...functions) => (value) => 
    functions.reduce((acc, func) => func(acc), value);

const pipeline = pipe(
    addOne,
    multiplyByTwo,
    square
);

console.log(pipeline(3)); // 64
        </div>

        <h2>2.3 불변성과 데이터 구조</h2>

        <h3>불변성의 중요성</h3>
        <div class="immutable-example">
            <p><strong>불변성의 장점:</strong></p>
            <ul>
                <li>예측 가능한 코드</li>
                <li>병렬 처리 안전성</li>
                <li>디버깅 용이성</li>
                <li>시간 여행 디버깅 가능</li>
            </ul>
        </div>

        <div class="code-example">
// 가변 데이터 구조 (피해야 할 방식)
const mutableArray = [1, 2, 3];
mutableArray.push(4);  // 원본 배열 변경

// 불변 데이터 구조 (권장 방식)
const originalArray = [1, 2, 3];
const newArray = [...originalArray, 4];  // 새로운 배열 생성

// 객체 불변성
const originalUser = { name: 'John', age: 30 };
const updatedUser = { ...originalUser, age: 31 };  // 새로운 객체 생성

// 깊은 객체 업데이트
const updateNestedProperty = (obj, path, value) => {
    const [head, ...rest] = path;
    return rest.length === 0
        ? { ...obj, [head]: value }
        : { ...obj, [head]: updateNestedProperty(obj[head], rest, value) };
};

const user = {
    profile: {
        personal: {
            name: 'Alice'
        }
    }
};

const updatedUserName = updateNestedProperty(
    user, 
    ['profile', 'personal', 'name'], 
    'Bob'
);
        </div>

        <h2>2.4 고차 함수와 함수형 패턴</h2>

        <h3>Map, Filter, Reduce</h3>
        <p>함수형 프로그래밍의 기본적인 데이터 변환 패턴입니다.</p>

        <div class="code-example">
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Map: 각 요소를 변환
const squared = numbers.map(x => x * x);
// [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

// Filter: 조건에 맞는 요소만 선택
const evenNumbers = numbers.filter(x => x % 2 === 0);
// [2, 4, 6, 8, 10]

// Reduce: 모든 요소를 하나의 값으로 축소
const sum = numbers.reduce((acc, curr) => acc + curr, 0);
// 55

// 복합적 사용
const result = numbers
    .filter(x => x % 2 === 1)  // 홀수만
    .map(x => x * x)           // 제곱
    .reduce((acc, curr) => acc + curr, 0);  // 합계
// 1 + 9 + 25 + 49 + 81 = 165
        </div>

        <h3>커링 (Currying)과 부분 적용 (Partial Application)</h3>
        <div class="concept-box">
            <p><strong>커링:</strong> 여러 개의 인자를 받는 함수를 인자 하나씩 받는 함수들의 체인으로 변환하는 기법</p>
            <p><strong>부분 적용:</strong> 함수의 일부 인자를 미리 고정하여 새로운 함수를 만드는 기법</p>
        </div>

        <div class="code-example">
// 커링 예제
const curriedAdd = (a) => (b) => (c) => a + b + c;
const addFive = curriedAdd(5);
const addFiveAndThree = addFive(3);
console.log(addFiveAndThree(2)); // 10

// 실용적인 커링 사용 예
const log = (level) => (message) => 
    console.log(`[${level}] ${new Date().toISOString()}: ${message}`);

const logError = log('ERROR');
const logInfo = log('INFO');

logError('Database connection failed');
logInfo('User logged in successfully');

// 부분 적용 예제
const multiply = (a, b, c) => a * b * c;
const partialMultiply = (a, b) => (c) => multiply(a, b, c);

const multiplyByTen = partialMultiply(2, 5);
console.log(multiplyByTen(3)); // 30
        </div>

        <h2>2.5 모나드와 함수자</h2>

        <h3>함수자 (Functor)</h3>
        <p>맵핑이 가능한 데이터 구조로, map 함수를 구현할 수 있는 컨테이너입니다.</p>

        <div class="code-example">
// Maybe 함수자 구현
class Maybe {
    constructor(value) {
        this.value = value;
    }
    
    static of(value) {
        return new Maybe(value);
    }
    
    map(fn) {
        return this.value == null 
            ? Maybe.of(null) 
            : Maybe.of(fn(this.value));
    }
    
    isNothing() {
        return this.value == null;
    }
    
    getValue() {
        return this.value;
    }
}

// 사용 예제
const safeDiv = (x, y) => y === 0 ? null : x / y;

const result1 = Maybe.of(10)
    .map(x => x * 2)
    .map(x => safeDiv(x, 4))
    .map(x => x + 1);

console.log(result1.getValue()); // 6

const result2 = Maybe.of(10)
    .map(x => x * 2)
    .map(x => safeDiv(x, 0))  // null 반환
    .map(x => x + 1);         // 실행되지 않음

console.log(result2.getValue()); // null
        </div>

        <h2>2.6 함수형 vs 객체지향 비교</h2>

        <table class="comparison-table">
            <thead>
                <tr>
                    <th>특성</th>
                    <th>함수형 프로그래밍</th>
                    <th>객체지향 프로그래밍</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>기본 단위</td>
                    <td>함수</td>
                    <td>객체</td>
                </tr>
                <tr>
                    <td>데이터</td>
                    <td>불변 (Immutable)</td>
                    <td>가변 (Mutable)</td>
                </tr>
                <tr>
                    <td>프로그래밍 스타일</td>
                    <td>선언적 (Declarative)</td>
                    <td>명령적 (Imperative)</td>
                </tr>
                <tr>
                    <td>코드 구성</td>
                    <td>함수 합성</td>
                    <td>클래스 상속</td>
                </tr>
                <tr>
                    <td>병렬 처리</td>
                    <td>안전함</td>
                    <td>동기화 필요</td>
                </tr>
                <tr>
                    <td>테스트</td>
                    <td>단순함</td>
                    <td>모킹 필요할 수 있음</td>
                </tr>
            </tbody>
        </table>

        <h2>2.7 실제 적용 사례</h2>

        <div class="real-world-example">
            <h3>데이터 처리 파이프라인</h3>
            <p>대용량 데이터를 처리하는 ETL 파이프라인을 함수형 스타일로 구현한 예제입니다.</p>
            
            <div class="code-example">
// 사용자 데이터 처리 파이프라인
const users = [
    { id: 1, name: 'Alice', age: 25, country: 'US', active: true },
    { id: 2, name: 'Bob', age: 30, country: 'UK', active: false },
    { id: 3, name: 'Charlie', age: 35, country: 'US', active: true },
    { id: 4, name: 'Diana', age: 28, country: 'CA', active: true }
];

// 함수형 변환 파이프라인
const processUsers = (users) => 
    users
        .filter(user => user.active)              // 활성 사용자만
        .filter(user => user.age >= 25)           // 25세 이상
        .map(user => ({                           // 필요한 필드만 추출
            id: user.id,
            name: user.name.toUpperCase(),
            ageGroup: user.age < 30 ? 'young' : 'adult',
            region: getRegion(user.country)
        }))
        .reduce((acc, user) => {                  // 지역별 그룹화
            const region = user.region;
            if (!acc[region]) acc[region] = [];
            acc[region].push(user);
            return acc;
        }, {});

const getRegion = (country) => {
    const regions = {
        'US': 'North America',
        'CA': 'North America',
        'UK': 'Europe'
    };
    return regions[country] || 'Other';
};

const result = processUsers(users);
console.log(result);
// {
//   "North America": [
//     { id: 1, name: "ALICE", ageGroup: "young", region: "North America" },
//     { id: 4, name: "DIANA", ageGroup: "young", region: "North America" }
//   ]
// }
            </div>
        </div>

        <h3>React에서의 함수형 프로그래밍</h3>
        <div class="real-world-example">
            <div class="code-example">
// 함수형 컴포넌트와 훅
import React, { useState, useEffect, useMemo } from 'react';

const useUserData = (userId) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        fetchUser(userId)
            .then(userData => {
                setUser(userData);
                setLoading(false);
            });
    }, [userId]);
    
    return { user, loading };
};

const UserProfile = ({ userId }) => {
    const { user, loading } = useUserData(userId);
    
    const displayName = useMemo(() => 
        user ? `${user.firstName} ${user.lastName}` : '',
        [user]
    );
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h1&gt;{displayName}&lt;/h1&gt;
            &lt;p&gt;Email: {user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};
            </div>
        </div>

        <h2>2.8 장단점 분석</h2>

        <div class="advantages">
            <h3>장점</h3>
            <ul>
                <li><strong>예측 가능성:</strong> 순수 함수로 인한 예측 가능한 동작</li>
                <li><strong>테스트 용이성:</strong> 부작용이 없어 단위 테스트 작성이 간단</li>
                <li><strong>병렬 처리:</strong> 불변 데이터로 인한 안전한 병렬 처리</li>
                <li><strong>디버깅:</strong> 상태 변경이 없어 디버깅이 쉬움</li>
                <li><strong>재사용성:</strong> 순수 함수는 다른 컨텍스트에서 재사용 가능</li>
                <li><strong>모듈화:</strong> 함수 단위의 작은 모듈로 구성</li>
            </ul>
        </div>

        <div class="disadvantages">
            <h3>단점</h3>
            <ul>
                <li><strong>학습 곡선:</strong> 함수형 개념과 패턴 이해 필요</li>
                <li><strong>성능 오버헤드:</strong> 불변 데이터 구조로 인한 메모리 사용량 증가</li>
                <li><strong>상태 관리:</strong> 상태가 필요한 애플리케이션에서 복잡함</li>
                <li><strong>가독성:</strong> 과도한 추상화로 인한 가독성 저하 가능</li>
                <li><strong>기존 라이브러리:</strong> 명령형 라이브러리와의 통합 어려움</li>
            </ul>
        </div>

        <h2>2.9 현대적 적용과 도구</h2>

        <h3>JavaScript/TypeScript</h3>
        <ul>
            <li>Ramda, Lodash/FP 라이브러리</li>
            <li>Immutable.js, Immer</li>
            <li>RxJS (반응형 프로그래밍)</li>
        </ul>

        <h3>기타 함수형 언어</h3>
        <ul>
            <li>Haskell, Clojure, F#</li>
            <li>Elm (웹 프론트엔드)</li>
            <li>Scala (JVM 기반)</li>
        </ul>

        <div class="summary-box">
            <div class="summary-title">핵심 요약</div>
            <ul>
                <li>함수형 프로그래밍은 <span class="highlight">순수 함수와 불변성</span>을 기반으로 합니다.</li>
                <li><span class="highlight">고차 함수</span>를 통해 코드의 재사용성과 추상화를 높입니다.</li>
                <li><span class="highlight">함수 합성</span>으로 복잡한 로직을 단순한 함수들의 조합으로 표현합니다.</li>
                <li><span class="highlight">선언적 프로그래밍</span> 스타일로 코드의 가독성을 향상시킵니다.</li>
                <li>현대 프레임워크에서 <span class="highlight">점진적 도입</span>이 가능합니다.</li>
            </ul>
        </div>
    </div>
</body>
</html>