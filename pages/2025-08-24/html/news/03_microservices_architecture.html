<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>제3장: 마이크로서비스 아키텍처 (Microservices Architecture)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Times New Roman', Georgia, serif;
            line-height: 1.8;
            color: #333;
            background-color: #fafafa;
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .chapter {
            background-color: white;
            padding: 50px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chapter-header {
            text-align: center;
            border-bottom: 3px solid #e67e22;
            padding-bottom: 20px;
            margin-bottom: 40px;
        }
        
        .chapter-number {
            color: #e74c3c;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .chapter-title {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .chapter-subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            font-style: italic;
        }
        
        h2 {
            color: #e67e22;
            font-size: 1.8em;
            margin: 30px 0 20px 0;
            border-left: 5px solid #f39c12;
            padding-left: 15px;
        }
        
        h3 {
            color: #27ae60;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }
        
        .definition-box {
            background: linear-gradient(135deg, #fdf4e3, #fef9e7);
            border-left: 5px solid #f39c12;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .definition-title {
            color: #e67e22;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .architecture-diagram {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            padding: 30px;
            margin: 20px 0;
            border-radius: 10px;
            text-align: center;
        }
        
        .service-box {
            display: inline-block;
            background: #e67e22;
            color: white;
            padding: 15px 20px;
            margin: 10px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .code-example {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
        
        .principles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .principle-card {
            background: #fff;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .principle-title {
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .advantages {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
        }
        
        .disadvantages {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
        }
        
        .pattern-box {
            background: #e8f4f8;
            border: 1px solid #b8daff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .pattern-title {
            color: #0056b3;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background-color: #e67e22;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .real-world-example {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
        }
        
        ul, ol {
            padding-left: 30px;
            margin: 15px 0;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .summary-box {
            background: #e9ecef;
            border: 2px solid #6c757d;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }
        
        .summary-title {
            color: #495057;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .tech-stack {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="chapter">
        <div class="chapter-header">
            <div class="chapter-number">제3장</div>
            <h1 class="chapter-title">마이크로서비스 아키텍처</h1>
            <div class="chapter-subtitle">Microservices Architecture</div>
        </div>

        <div class="definition-box">
            <div class="definition-title">정의</div>
            <p>마이크로서비스 아키텍처는 단일 애플리케이션을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 소프트웨어 아키텍처 패턴입니다. 각 서비스는 특정 비즈니스 기능을 담당하고, 경량의 메커니즘(주로 HTTP API)을 통해 통신하며, 서로 다른 프로그래밍 언어와 데이터 저장 기술을 사용할 수 있습니다.</p>
        </div>

        <h2>3.1 마이크로서비스 vs 모놀리식 아키텍처</h2>

        <div class="architecture-diagram">
            <h3>모놀리식 아키텍처</h3>
            <div style="background: #6c757d; color: white; padding: 30px; border-radius: 10px; margin: 20px 0;">
                <strong>단일 애플리케이션</strong><br>
                UI + Business Logic + Data Access
            </div>
            
            <h3 style="margin-top: 40px;">마이크로서비스 아키텍처</h3>
            <div>
                <div class="service-box">User Service</div>
                <div class="service-box">Order Service</div>
                <div class="service-box">Payment Service</div>
                <div class="service-box">Inventory Service</div>
            </div>
        </div>

        <table class="comparison-table">
            <thead>
                <tr>
                    <th>특성</th>
                    <th>모놀리식</th>
                    <th>마이크로서비스</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>배포</td>
                    <td>전체 애플리케이션</td>
                    <td>개별 서비스</td>
                </tr>
                <tr>
                    <td>확장성</td>
                    <td>전체 스케일링</td>
                    <td>서비스별 스케일링</td>
                </tr>
                <tr>
                    <td>기술 스택</td>
                    <td>단일 기술</td>
                    <td>서비스별 다양한 기술</td>
                </tr>
                <tr>
                    <td>개발팀 구조</td>
                    <td>중앙집중식</td>
                    <td>분산된 팀</td>
                </tr>
                <tr>
                    <td>데이터베이스</td>
                    <td>공유 데이터베이스</td>
                    <td>서비스별 독립 데이터베이스</td>
                </tr>
            </tbody>
        </table>

        <h2>3.2 마이크로서비스의 핵심 원칙</h2>

        <div class="principles-grid">
            <div class="principle-card">
                <div class="principle-title">단일 책임</div>
                <p>각 서비스는 하나의 비즈니스 기능에 집중하며, 독립적으로 변경되고 배포될 수 있어야 합니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">분산 거버넌스</div>
                <p>각 팀이 자신의 서비스에 대한 기술 선택과 운영 방식을 결정할 수 있는 자율성을 가져야 합니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">장애 격리</div>
                <p>한 서비스의 장애가 전체 시스템에 영향을 주지 않도록 격리되어야 합니다.</p>
            </div>
            
            <div class="principle-card">
                <div class="principle-title">분산 데이터 관리</div>
                <p>각 서비스는 자체 데이터베이스를 가지며, 데이터 일관성은 최종적 일관성으로 관리합니다.</p>
            </div>
        </div>

        <h2>3.3 서비스 분해 전략</h2>

        <h3>비즈니스 기능별 분해</h3>
        <div class="pattern-box">
            <div class="pattern-title">도메인 기반 분해</div>
            <p>비즈니스 도메인과 기능에 따라 서비스를 나누는 방법입니다.</p>
            
            <div class="code-example">
// 전자상거래 시스템의 서비스 분해 예제

// 사용자 서비스
User Service:
- 사용자 등록/인증
- 프로필 관리
- 권한 관리

// 상품 서비스
Product Service:
- 상품 카탈로그
- 상품 검색
- 재고 관리

// 주문 서비스
Order Service:
- 주문 생성/처리
- 주문 상태 관리
- 주문 이력

// 결제 서비스
Payment Service:
- 결제 처리
- 결제 이력
- 환불 관리
            </div>
        </div>

        <h3>데이터 기반 분해</h3>
        <div class="pattern-box">
            <div class="pattern-title">Database per Service 패턴</div>
            <p>각 마이크로서비스는 자체 데이터베이스를 가지며, 다른 서비스의 데이터에 직접 접근하지 않습니다.</p>
        </div>

        <h2>3.4 마이크로서비스 통신 패턴</h2>

        <h3>동기 통신</h3>
        <div class="code-example">
// REST API를 통한 서비스 간 통신
// Order Service에서 User Service 호출

@RestController
public class OrderController {
    
    @Autowired
    private UserServiceClient userServiceClient;
    
    @PostMapping("/orders")
    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody CreateOrderRequest request) {
        // 사용자 정보 조회
        User user = userServiceClient.getUser(request.getUserId());
        if (user == null) {
            return ResponseEntity.badRequest().build();
        }
        
        // 주문 생성
        Order order = new Order();
        order.setUserId(user.getId());
        order.setUserName(user.getName());
        
        return ResponseEntity.ok(orderService.createOrder(order));
    }
}

// Feign Client 사용 예제
@FeignClient(name = "user-service")
public interface UserServiceClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable("id") Long id);
}
        </div>

        <h3>비동기 통신</h3>
        <div class="code-example">
// 이벤트 기반 비동기 통신 (Spring Cloud Stream + RabbitMQ)

// 주문 생성 시 이벤트 발행
@Service
public class OrderService {
    
    @Autowired
    private StreamBridge streamBridge;
    
    public Order createOrder(Order order) {
        Order savedOrder = orderRepository.save(order);
        
        // 주문 생성 이벤트 발행
        OrderCreatedEvent event = new OrderCreatedEvent(
            savedOrder.getId(),
            savedOrder.getUserId(),
            savedOrder.getTotalAmount()
        );
        
        streamBridge.send("orderCreated-out-0", event);
        
        return savedOrder;
    }
}

// 다른 서비스에서 이벤트 처리
@Component
public class InventoryEventHandler {
    
    @EventListener
    public void handle(OrderCreatedEvent event) {
        // 재고 차감 로직
        inventoryService.reduceStock(event.getOrderId());
    }
}
        </div>

        <h2>3.5 데이터 관리 패턴</h2>

        <h3>Saga 패턴</h3>
        <div class="pattern-box">
            <div class="pattern-title">분산 트랜잭션 관리</div>
            <p>여러 서비스에 걸친 트랜잭션을 관리하기 위한 패턴으로, 각 단계별로 보상 트랜잭션을 정의합니다.</p>
            
            <div class="code-example">
// Order Saga 구현 예제
@Component
public class OrderSaga {
    
    public void processOrder(Order order) {
        try {
            // 1. 결제 처리
            paymentService.processPayment(order);
            
            // 2. 재고 차감
            inventoryService.reduceStock(order);
            
            // 3. 주문 확정
            orderService.confirmOrder(order);
            
        } catch (PaymentException e) {
            // 보상 트랜잭션 불필요 (결제 실패)
            orderService.cancelOrder(order);
            
        } catch (InventoryException e) {
            // 결제 취소 (보상 트랜잭션)
            paymentService.refundPayment(order);
            orderService.cancelOrder(order);
            
        } catch (Exception e) {
            // 전체 롤백
            inventoryService.restoreStock(order);
            paymentService.refundPayment(order);
            orderService.cancelOrder(order);
        }
    }
}
            </div>
        </div>

        <h3>CQRS (Command Query Responsibility Segregation)</h3>
        <div class="pattern-box">
            <div class="pattern-title">명령과 조회 분리</div>
            <p>데이터 수정 작업과 조회 작업을 분리하여 각각 최적화하는 패턴입니다.</p>
        </div>

        <h2>3.6 서비스 디스커버리와 로드 밸런싱</h2>

        <h3>Service Registry 패턴</h3>
        <div class="code-example">
// Eureka를 이용한 서비스 등록 (Spring Cloud Netflix)

// 서비스 등록 (application.yml)
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true

// 서비스 디스커버리 사용
@RestController
public class OrderController {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @GetMapping("/user-services")
    public List&lt;ServiceInstance&gt; getUserServices() {
        return discoveryClient.getInstances("user-service");
    }
}

// 로드 밸런서 사용
@Autowired
@LoadBalanced
private RestTemplate restTemplate;

public User getUser(Long userId) {
    return restTemplate.getForObject(
        "http://user-service/users/" + userId, 
        User.class
    );
}
        </div>

        <h2>3.7 마이크로서비스 보안</h2>

        <h3>API Gateway 패턴</h3>
        <div class="pattern-box">
            <div class="pattern-title">단일 진입점 제공</div>
            <p>모든 클라이언트 요청을 받아 적절한 마이크로서비스로 라우팅하는 게이트웨이입니다.</p>
            
            <div class="code-example">
// Spring Cloud Gateway 설정
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - name: AuthenticationFilter
            - name: RateLimiter
              args:
                rate-limiter: "#{@userRateLimiter}"
        
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: AuthenticationFilter
            </div>
        </div>

        <h3>JWT 기반 인증</h3>
        <div class="code-example">
// JWT 토큰 검증 필터
@Component
public class JwtAuthenticationFilter implements GlobalFilter {
    
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, 
                            GatewayFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        
        if (token != null && jwtUtil.validateToken(token)) {
            String userId = jwtUtil.getUserIdFromToken(token);
            
            // 요청 헤더에 사용자 정보 추가
            ServerHttpRequest request = exchange.getRequest()
                .mutate()
                .header("X-User-Id", userId)
                .build();
            
            return chain.filter(exchange.mutate().request(request).build());
        }
        
        return unauthorized(exchange.getResponse());
    }
}
        </div>

        <h2>3.8 모니터링과 로깅</h2>

        <h3>분산 추적 (Distributed Tracing)</h3>
        <div class="tech-stack">
            <h4>주요 도구</h4>
            <ul>
                <li><strong>Spring Cloud Sleuth:</strong> 자동 추적 데이터 생성</li>
                <li><strong>Zipkin:</strong> 분산 추적 시각화</li>
                <li><strong>Jaeger:</strong> Uber에서 개발한 분산 추적 시스템</li>
                <li><strong>OpenTelemetry:</strong> 표준화된 관측성 프레임워크</li>
            </ul>
        </div>

        <div class="code-example">
// Spring Cloud Sleuth 설정
spring:
  sleuth:
    sampler:
      probability: 0.1  # 10% 샘플링
    zipkin:
      base-url: http://zipkin-server:9411
      
// 커스텀 스팬 생성
@NewSpan("order-processing")
public void processOrder(@SpanTag("orderId") String orderId) {
    // 주문 처리 로직
    tracer.nextSpan()
        .name("payment-processing")
        .tag("orderId", orderId)
        .start();
    
    // 결제 처리
    
    span.end();
}
        </div>

        <h2>3.9 장단점 분석</h2>

        <div class="advantages">
            <h3>장점</h3>
            <ul>
                <li><strong>독립적 배포:</strong> 각 서비스를 독립적으로 배포하고 확장 가능</li>
                <li><strong>기술 다양성:</strong> 서비스별로 최적의 기술 스택 선택 가능</li>
                <li><strong>팀 자율성:</strong> 작은 팀이 서비스 전체를 담당하여 생산성 향상</li>
                <li><strong>장애 격리:</strong> 한 서비스의 장애가 전체 시스템에 영향을 주지 않음</li>
                <li><strong>선택적 확장:</strong> 필요한 서비스만 선택적으로 확장 가능</li>
                <li><strong>레거시 점진적 마이그레이션:</strong> 기존 시스템을 점진적으로 분해 가능</li>
            </ul>
        </div>

        <div class="disadvantages">
            <h3>단점</h3>
            <ul>
                <li><strong>복잡성 증가:</strong> 분산 시스템의 복잡성 관리 필요</li>
                <li><strong>네트워크 지연:</strong> 서비스 간 통신으로 인한 지연</li>
                <li><strong>데이터 일관성:</strong> 분산 트랜잭션 관리의 어려움</li>
                <li><strong>운영 오버헤드:</strong> 다수의 서비스 모니터링과 관리</li>
                <li><strong>테스트 복잡성:</strong> 서비스 간 통합 테스트의 어려움</li>
                <li><strong>초기 비용:</strong> 인프라와 도구 구축에 많은 비용</li>
            </ul>
        </div>

        <h2>3.10 실제 적용 사례</h2>

        <div class="real-world-example">
            <h3>Netflix의 마이크로서비스 아키텍처</h3>
            <p>Netflix는 2000개 이상의 마이크로서비스를 운영하며, 하루에 수십억 건의 API 호출을 처리합니다.</p>
            
            <div class="tech-stack">
                <h4>Netflix의 핵심 기술 스택</h4>
                <ul>
                    <li><strong>Service Discovery:</strong> Eureka</li>
                    <li><strong>Circuit Breaker:</strong> Hystrix</li>
                    <li><strong>API Gateway:</strong> Zuul</li>
                    <li><strong>Configuration Management:</strong> Archaius</li>
                    <li><strong>Load Balancing:</strong> Ribbon</li>
                </ul>
            </div>
        </div>

        <div class="real-world-example">
            <h3>Amazon의 서비스 분해 여정</h3>
            <p>Amazon은 모놀리식 아키텍처에서 시작하여 현재 수만 개의 마이크로서비스로 운영됩니다.</p>
            
            <ul>
                <li>2001년: Two-Pizza Team 규칙 도입</li>
                <li>2006년: AWS 서비스로 인프라 제공</li>
                <li>현재: 각 팀이 독립적으로 서비스 운영</li>
            </ul>
        </div>

        <h2>3.11 도입 전략과 모범 사례</h2>

        <h3>점진적 마이그레이션</h3>
        <div class="pattern-box">
            <div class="pattern-title">Strangler Fig 패턴</div>
            <p>기존 모놀리식 애플리케이션을 점진적으로 마이크로서비스로 분해하는 패턴입니다.</p>
            
            <ol>
                <li>API Gateway를 통해 트래픽을 제어</li>
                <li>하나의 기능을 새로운 마이크로서비스로 추출</li>
                <li>점진적으로 기능을 이전</li>
                <li>모놀리식에서 해당 기능 제거</li>
            </ol>
        </div>

        <div class="summary-box">
            <div class="summary-title">핵심 요약</div>
            <ul>
                <li>마이크로서비스는 <span class="highlight">독립적 배포와 확장</span>이 가능한 작은 서비스들로 구성됩니다.</li>
                <li><span class="highlight">비즈니스 기능별 분해</span>를 통해 팀의 자율성을 높입니다.</li>
                <li><span class="highlight">API Gateway와 Service Discovery</span>로 서비스 간 통신을 관리합니다.</li>
                <li><span class="highlight">분산 시스템의 복잡성</span>을 적절히 관리해야 합니다.</li>
                <li><span class="highlight">점진적 도입</span>을 통해 리스크를 최소화할 수 있습니다.</li>
            </ul>
        </div>
    </div>
</body>
</html>